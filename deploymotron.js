// Generated by CoffeeScript 1.4.0
(function() {
  var CMM_PHP_REPO, history, pipeline;

  pipeline = [];

  history = [];

  CMM_PHP_REPO = process.env["CMM_PHP_REPO"];

  module.exports = function(robot) {
    var branchUrl, getSHAofBranch, newPipeUnit, readyForBranch, shaChange, shaMatches;
    if (robot === "wipe") {
      pipeline = [];
      return {};
    }
    newPipeUnit = function(featureName) {
      return {
        branch: featureName,
        lsotd: false
      };
    };
    branchUrl = function(branchName) {
      return "" + CMM_PHP_REPO + "/" + branchName;
    };
    getSHAofBranch = function(branchName, callback) {
      return robot.http(branchUrl(branchName)).get()(function(err, res, body) {
        var ghData;
        ghData = JSON.parse(body);
        return callback(ghData['message'], ghData['object']);
      });
    };
    readyForBranch = function(branch) {
      console.log("The staging environment is ready for " + branch);
      return robot.messageRoom("The staging environment is ready for " + branch);
    };
    shaMatches = function(masterSHA, pipeSHA) {
      history.push(pipeline.shift());
      if (pipeline[0]) {
        return readyForBranch(pipeline[0].branch);
      }
    };
    shaChange = {
      "true": shaMatches,
      "false": function(masterSHA, pipeSHA) {
        return robot.messageRoom("Master was updated, but doesn't match the SHA at the front of the pipe\n    Master: " + masterSHA + "\n  Pipeline: " + pipeSHA);
      }
    };
    robot.router.post('/deploymotron', function(req, res) {
      var masterSHA;
      if (!pipeline[0]) {
        return;
      }
      masterSHA = JSON.parse(req.body.payload)['sha'];
      return getSHAofBranch(pipeline[0].branch, function(err, ghData) {
        if (err) {
          return robot.messageRoom(err);
        }
        return shaChange[masterSHA === ghData.sha](masterSHA, ghData.sha);
      });
    });
    robot.hear(/deploymotron, ls/i, function(msg) {
      return msg.send("" + pipeline.map(function(pipeUnit) {
        return pipeUnit.branch;
      }));
    });
    robot.hear(/deploymotron, << (.+)/i, function(msg) {
      var feature, newUnit;
      feature = msg.match[1];
      newUnit = newPipeUnit(feature);
      pipeline.push(newUnit);
      if (pipeline.length > 1) {
        return msg.send("You're number: " + pipeline.length + " in the pipeline");
      } else {
        return readyForBranch(newUnit.branch);
      }
    });
    return robot.hear(/deploymotron, dump/i, function(msg) {
      return msg.send(JSON.stringify(pipeline));
    });
  };

}).call(this);
